# Cloudinary React SDK Patterns & Common Errors

**Scope**: These rules apply to **React (web)** with Vite and the browser Upload Widget. For **React Native** uploads (including signed upload), see: https://cloudinary.com/documentation/react_native_image_and_video_upload#signed_upload ‚Äî same ‚Äúnever expose secret, generate signature on backend‚Äù principle, but React Native uses the `upload()` method and backend SDKs differently.

## Official Documentation
- **Transformation Rules**: https://cloudinary.com/documentation/cloudinary_transformation_rules.md
- **Transformation Reference**: https://cloudinary.com/documentation/transformation_reference
- **React Image Transformations & Plugins**: https://cloudinary.com/documentation/react_image_transformations#plugins
- **React Video Transformations**: https://cloudinary.com/documentation/react_video_transformations
- **Cloudinary Video Player** (standalone player): https://cloudinary.com/documentation/cloudinary_video_player
- **Video Player React Tutorial**: https://cloudinary.com/documentation/video_player_react_tutorial#banner
- **Upload Widget (signed uploads)**: https://cloudinary.com/documentation/upload_widget#signed_uploads
- **Upload assets in Next.js (backend signature)**: https://cloudinary.com/documentation/upload_assets_in_nextjs_tutorial
- **Cloudinary Node.js SDK (server-side signing)** ‚Äî use **v2**: `import { v2 as cloudinary } from 'cloudinary'`; do not use v1 (e.g. 1.47.0). https://cloudinary.com/documentation/node_integration
- **React Native image and video upload (signed)**: https://cloudinary.com/documentation/react_native_image_and_video_upload#signed_upload
- Always consult the official transformation rules when creating transformations
- Use only officially supported parameters from the transformation reference

---

# üìã PATTERNS (How to Do It Right)

## Environment Variables
- **Vite requires VITE_ prefix** - Environment variables MUST start with `VITE_` to be exposed to the browser
- ‚úÖ CORRECT: `VITE_CLOUDINARY_CLOUD_NAME=mycloud` in `.env` file
- ‚úÖ CORRECT: `import.meta.env.VITE_CLOUDINARY_CLOUD_NAME` (not `process.env`)
- Always restart dev server after adding/updating `.env` variables

## Upload Presets
- **Unsigned** = client-only uploads (no backend). **Signed** = backend required, more secure. See **"Signed vs unsigned uploads"** below for when to use which.
- ‚úÖ Create unsigned upload preset (for simple client uploads): https://console.cloudinary.com/app/settings/upload/presets
- ‚úÖ Set preset in `.env`: `VITE_CLOUDINARY_UPLOAD_PRESET=your-preset-name`
- ‚úÖ Use in code: `import { uploadPreset } from './cloudinary/config'`
- ‚ö†Ô∏è If upload preset is missing, the Upload Widget will show an error message
- ‚ö†Ô∏è Upload presets must be set to "Unsigned" mode for client-side usage (no API key/secret needed)
- **When unsigned upload fails**: First check that the user configured their upload preset:
  1. Is `VITE_CLOUDINARY_UPLOAD_PRESET` set in `.env`? (must match preset name exactly)
  2. Does the preset exist in the dashboard under Settings ‚Üí Upload ‚Üí Upload presets?
  3. Is the preset set to **Unsigned** (not Signed)?
  4. Was the dev server restarted after adding/updating `.env`?

## Import Patterns
- ‚úÖ Import Cloudinary instance: `import { cld } from './cloudinary/config'`
- ‚úÖ Import components: `import { AdvancedImage, AdvancedVideo } from '@cloudinary/react'`
- ‚úÖ Import transformations: `import { fill } from '@cloudinary/url-gen/actions/resize'`
- ‚úÖ Import effects: `import { blur } from '@cloudinary/url-gen/actions/effect'`
- ‚úÖ Import delivery: `import { format, quality } from '@cloudinary/url-gen/actions/delivery'`
- ‚úÖ Import qualifiers: `import { auto } from '@cloudinary/url-gen/qualifiers/format'`
- ‚úÖ Import qualifiers: `import { auto as autoQuality } from '@cloudinary/url-gen/qualifiers/quality'`
- ‚úÖ Import plugins: `import { responsive, lazyload, placeholder } from '@cloudinary/react'`

## Creating Image & Video Instances
- ‚úÖ Create image instance: `const img = cld.image(publicId)`
- ‚úÖ Create video instance: `const video = cld.video(publicId)` (same pattern as images)
- ‚úÖ Public ID format: Use forward slashes for folders (e.g., `'folder/subfolder/image'`)
- ‚úÖ Public IDs are case-sensitive and should not include file extensions
- ‚úÖ Examples:
  ```tsx
  const displayImage = cld.image('samples/cloudinary-icon');
  const displayVideo = cld.video('samples/elephants');
  ```

## Transformation Patterns

### Image Transformations
- ‚úÖ Chain transformations on image instance:
  ```tsx
  const img = cld.image('id')
    .resize(fill().width(800).height(600))
    .effect(blur(800))
    .delivery(format(auto()))
    .delivery(quality(autoQuality()));
  ```
- ‚úÖ Pass to component: `<AdvancedImage cldImg={img} />`

### Video Transformations
- ‚úÖ Chain transformations on video instance (same pattern as images):
  ```tsx
  const video = cld.video('id')
    .resize(fill().width(800).height(600))
    .delivery(format(auto()));
  ```
- ‚úÖ Pass to component: `<AdvancedVideo cldVid={video} />`
- ‚úÖ Video transformations work the same way as image transformations

### Transformation Best Practices
- ‚úÖ Format and quality must use separate `.delivery()` calls
- ‚úÖ Always end with auto format/quality: `.delivery(format(auto())).delivery(quality(autoQuality()))`
- ‚úÖ Use `gravity(auto())` unless user specifies a focal point
- ‚úÖ Same transformation syntax works for both images and videos

## Plugin Patterns
- ‚úÖ Import plugins from `@cloudinary/react`
- ‚úÖ Pass plugins as array: `plugins={[responsive(), lazyload(), placeholder()]}`
- ‚úÖ Recommended plugin order:
  1. `responsive()` - First
  2. `lazyload()` - Second
  3. `accessibility()` - Third
  4. `placeholder()` - Last
- ‚úÖ Always add `width` and `height` attributes to prevent layout shift
- ‚úÖ Example:
  ```tsx
  <AdvancedImage
    cldImg={img}
    plugins={[responsive(), lazyload(), placeholder({ mode: 'blur' })]}
    width={800}
    height={600}
  />
  ```

## Responsive Images Pattern
- ‚úÖ Use `responsive()` plugin with `fill()` resize
- ‚úÖ Combine with `placeholder()` and `lazyload()` plugins
- ‚úÖ Example:
  ```tsx
  const img = cld.image('id').resize(fill().width(800));
  <AdvancedImage 
    cldImg={img} 
    plugins={[responsive(), placeholder({ mode: 'blur' }), lazyload()]} 
    width={800}
    height={600}
  />
  ```

## Upload Widget Pattern
- ‚úÖ Use component: `import { UploadWidget } from './cloudinary/UploadWidget'`
- ‚úÖ Load script in `index.html`:
  ```html
  <script src="https://upload-widget.cloudinary.com/global/all.js" async></script>
  ```
- ‚úÖ Create unsigned upload preset in dashboard at `settings/upload/presets`
- ‚úÖ Add to `.env`: `VITE_CLOUDINARY_UPLOAD_PRESET=your_preset_name`
- ‚úÖ Handle callbacks:
  ```tsx
  <UploadWidget
    onUploadSuccess={(result) => {
      console.log('Public ID:', result.public_id);
    }}
    onUploadError={(error) => {
      console.error('Upload failed:', error);
    }}
  />
  ```
- ‚úÖ Upload result contains: `public_id`, `secure_url`, `width`, `height`, etc.

## Signed vs unsigned uploads (when to use which)

**Unsigned uploads** (simpler, no backend required):
- Use when: Quick prototypes, low-risk apps, or when anyone with the preset name may upload.
- Preset: Create an **Unsigned** upload preset in Cloudinary dashboard (Settings ‚Üí Upload ‚Üí Upload presets). Put preset name in `.env` as `VITE_CLOUDINARY_UPLOAD_PRESET`.
- Client: Widget needs only `cloudName` and `uploadPreset`. No API key or secret; no backend.
- Trade-off: Anyone who knows the preset name can upload. Use only when that is acceptable.

**Signed uploads** (more secure, backend required):
- Use when: Production apps, authenticated users, or when you need to control who can upload.
- Preset: Create a **Signed** upload preset in the dashboard. The backend generates a signature using your API secret; the client never sees the secret.
- Client: Widget gets `api_key` (from your backend), `uploadPreset`, and an `uploadSignature` **function** that calls your backend for each upload. API secret stays on server only.
- Trade-off: Requires a backend (Node/Express, Next.js API route, etc.) to sign requests. More secure; signature validates each upload.

**Rule of thumb**: If the user asks for "secure" or "signed" uploads, or needs to restrict uploads, use **signed** with a backend. For simple demos or when preset exposure is acceptable, **unsigned** is fine.

## Secure (Signed) Uploads

**Golden rules**: (1) **Never expose or commit the API secret** ‚Äî it must live only in server env and server code. (2) **Never commit the API key or secret** ‚Äî use `server/.env` (or equivalent) and ensure it is in `.gitignore`. (3) The **api_key** is not secret and may be sent to the client (e.g. in the signature response); only **api_secret** must stay server-only.

**When the user asks for secure uploads**: Use a signed upload preset and generate the signature on the server. The client may receive `uploadSignature`, `uploadSignatureTimestamp`, `api_key`, and `cloudName` from your backend; it must **never** receive or contain the API secret.

### Where to put API key and secret (server-only, never committed)

- **Do not put them in the root `.env`** used by Vite. Keep root `.env` for `VITE_CLOUDINARY_CLOUD_NAME` and `VITE_CLOUDINARY_UPLOAD_PRESET` only.
- **Create `server/.env`** (in a `server/` folder) and put there: `CLOUDINARY_CLOUD_NAME`, `CLOUDINARY_API_KEY`, `CLOUDINARY_API_SECRET`. No `VITE_` prefix. Load this file only in the server process (e.g. `dotenv.config({ path: 'server/.env' })`).
- **Never commit API key or secret**: Add `server/.env` to `.gitignore`. Use env vars for all credentials; never hardcode or commit them.
- **In code**: Read `process.env.CLOUDINARY_API_SECRET` and `process.env.CLOUDINARY_API_KEY` only in server/API code. Never in React components or any file Vite bundles.
- **Next.js**: `CLOUDINARY_*` in root `.env.local` is server-only (browser only sees `NEXT_PUBLIC_*`). For Vite + Node in same repo, prefer `server/.env` and load it only in the server.
- **Server SDK**: Use the **Cloudinary Node.js SDK v2** for server-side signing: `import { v2 as cloudinary } from 'cloudinary'` (package name: `cloudinary`). Do **not** use v1 (e.g. 1.47.0) ‚Äî v1 does not expose `cloudinary.utils.api_sign_request` the same way. Install: `npm install cloudinary` (v2).

### How the client gets credentials (working pattern ‚Äî use this)

Use **`uploadSignature` as a function** (not `signatureEndpoint`). The widget calls the function with `params_to_sign`; your function calls your backend and passes the signature back. This pattern is reliable across widget versions.

1. **Fetch `api_key` from server first** (before creating the widget). API key is not secret; safe to use in client. Your backend returns it from the sign endpoint (e.g. `/api/sign-image`).

2. **Set `uploadSignature` to a function** that receives `(callback, params_to_sign)` from the widget. Inside the function, add `upload_preset` to `params_to_sign` (use your signed preset name, e.g. from env or a constant), POST to your backend with `{ params_to_sign: paramsWithPreset }`, then call `callback(data.signature)` with the response.

3. **Include `uploadPreset` in the widget config** (your signed preset name). The widget needs it so it includes it in `params_to_sign`. **Default:** Cloudinary accounts have a built-in signed preset `ml_default` (users can delete it). If the user has not created their own signed preset, use `ml_default`; otherwise use the preset name from their dashboard.

4. **Server endpoint**: Accept `params_to_sign` from the request body. Always include `upload_preset` in the object you sign (add it if the client did not send it). Use `cloudinary.utils.api_sign_request(paramsToSign, process.env.CLOUDINARY_API_SECRET)` to generate the signature. Return `{ signature, timestamp, api_key, cloud_name }`. Never return the API secret.

**Preset name:** Use `ml_default` when the user has not specified a signed preset (Cloudinary provides it by default; users can delete it ‚Äî then they must create one in the dashboard). Otherwise use the user's preset name.

**Generic client pattern** (preset: use `ml_default` if it exists / user hasn't specified one; endpoint is up to the user):
```tsx
// Fetch api_key from server first, then:
widgetConfig.api_key = data.api_key; // from your sign endpoint
widgetConfig.uploadPreset = 'ml_default'; // default signed preset (or user's preset if they created one)
widgetConfig.uploadSignature = function(callback, params_to_sign) {
  const paramsWithPreset = { ...params_to_sign, upload_preset: 'ml_default' };
  fetch('/api/sign-image', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ params_to_sign: paramsWithPreset }),
  })
    .then(r => r.json())
    .then(data => data.signature ? callback(data.signature) : callback(''))
    .catch(() => callback(''));
};
```

**Generic server pattern** (Node/Express with SDK v2):
```ts
// import { v2 as cloudinary } from 'cloudinary';
const params = req.body.params_to_sign || {};
const paramsToSign = { ...params, upload_preset: params.upload_preset || 'ml_default' };
const signature = cloudinary.utils.api_sign_request(paramsToSign, process.env.CLOUDINARY_API_SECRET);
res.json({ signature, timestamp: paramsToSign.timestamp, api_key: process.env.CLOUDINARY_API_KEY, cloud_name: process.env.CLOUDINARY_CLOUD_NAME });
```

- ‚ùå **Avoid `signatureEndpoint`** ‚Äî it may not be called reliably by all widget versions. Prefer the `uploadSignature` function.
- ‚úÖ Docs: [Upload widget ‚Äî signed uploads](https://cloudinary.com/documentation/upload_widget#signed_uploads), [Upload assets in Next.js](https://cloudinary.com/documentation/upload_assets_in_nextjs_tutorial).

### Rules for secure uploads
- ‚úÖ Use a **signed** upload preset (dashboard ‚Üí Upload presets ‚Üí Signed). Do not use an unsigned preset when the user wants secure uploads. **Default:** Accounts have a built-in signed preset `ml_default` ‚Äî use it if the user hasn't created their own (they can delete `ml_default`, in which case they must create a signed preset in the dashboard).
- ‚úÖ Generate the signature **on the server only** using Cloudinary Node.js SDK **v2** (`cloudinary.utils.api_sign_request`). Never put `CLOUDINARY_API_SECRET` in a `VITE_` variable or in client-side code.
- ‚úÖ Keep `server/.env` in `.gitignore`; never commit API key or secret.
- ‚úÖ Use **`uploadSignature` as a function** (not `signatureEndpoint`) for reliable signed uploads.
- ‚úÖ Include **`uploadPreset` in the widget config** so the widget includes it in `params_to_sign`.
- ‚úÖ **Server must include `upload_preset` in the signed params** (add it if the client did not send it).

### What not to do
- ‚ùå **Never** put the API secret in a `VITE_` (or `NEXT_PUBLIC_`) variable or in any file sent to the browser.
- ‚ùå **Never** commit the API key or secret; use env vars and ignore `server/.env` in git.
- ‚ùå **Do not** generate the signature in client-side JavaScript (it would require the secret in the client).
- ‚ùå **Do not** use an unsigned preset when the user explicitly wants secure/signed uploads.
- ‚ùå **Do not** omit `uploadPreset` from the widget config when using signed uploads (widget needs it in `params_to_sign`).
- ‚ùå **Do not** use Cloudinary Node SDK v1 (e.g. 1.47.0) for signing ‚Äî use v2 (`import { v2 as cloudinary } from 'cloudinary'`).
- ‚ùå **Do not** rely on `signatureEndpoint` alone; use the `uploadSignature` function for reliability.

## Video Patterns

### ‚ö†Ô∏è IMPORTANT: Two Different Approaches

**1. AdvancedVideo Component** (`@cloudinary/react`) - For video transformations
- React component similar to `AdvancedImage`
- Use for displaying videos with Cloudinary transformations
- Works with `cld.video()` like images work with `cld.image()`
- Simple, React-friendly approach

**2. Cloudinary Video Player** (`cloudinary-video-player`) - For advanced player features
- Standalone video player library
- Use for advanced features: playlists, recommendations, ads, chapters, etc.
- Full-featured player with analytics, monetization, etc.
- More complex setup, but more powerful

### AdvancedVideo Component (React SDK - For Transformations)
- ‚úÖ **Purpose**: Display videos with Cloudinary transformations (resize, effects, etc.)
- ‚úÖ **Package**: `@cloudinary/react` (same as AdvancedImage)
- ‚úÖ **Import**: `import { AdvancedVideo } from '@cloudinary/react'`
- ‚úÖ **NO CSS IMPORT NEEDED**: AdvancedVideo uses native HTML5 video - no CSS import required
- ‚ùå **WRONG**: `import '@cloudinary/react/dist/cld-video-player.css'` (this path doesn't exist)
- ‚úÖ **Create video instance**: `const video = cld.video(publicId)` (like `cld.image()`)
- ‚úÖ **Apply transformations**: Chain transformations like images:
  ```tsx
  const video = cld.video('video-id')
    .resize(fill().width(800).height(600))
    .delivery(format(auto()));
  ```
- ‚úÖ **Use component**:
  ```tsx
  <AdvancedVideo
    cldVid={video}
    controls
    autoplay
    muted
  />
  ```
- ‚úÖ **Documentation**: https://cloudinary.com/documentation/react_video_transformations

### Cloudinary Video Player (Standalone - For Advanced Features)
- ‚úÖ **Purpose**: Full-featured video player with playlists, recommendations, ads, etc.
- ‚úÖ **Package**: `cloudinary-video-player` (separate package)
- ‚úÖ **Import**: `import cloudinary from 'cloudinary-video-player'`
- ‚úÖ **Import CSS**: `import 'cloudinary-video-player/dist/cld-video-player.css'`
- ‚úÖ **Import modules** (for advanced features):
  ```tsx
  import 'cloudinary-video-player/dist/adaptive-streaming'; // HLS/DASH
  import 'cloudinary-video-player/dist/playlist'; // Playlists
  import 'cloudinary-video-player/dist/recommendations-overlay'; // Recommendations
  // Or import all: import 'cloudinary-video-player/dist/all'
  ```
- ‚úÖ **Initialize in useEffect** with cleanup:
  ```tsx
  useEffect(() => {
    const player = cloudinary.videoPlayer(ref.current, {
      cloud_name: import.meta.env.VITE_CLOUDINARY_CLOUD_NAME,
      secure: true,
      controls: true,
    });
    player.source(publicId);
    return () => player.dispose(); // Always cleanup!
  }, [publicId]);
  ```
- ‚úÖ **Video element classes**: `className="cld-video-player cld-fluid"`
- ‚úÖ **Documentation**: https://cloudinary.com/documentation/cloudinary_video_player
- ‚úÖ **React Tutorial**: https://cloudinary.com/documentation/video_player_react_tutorial#banner

### When to Use Which?
- ‚úÖ **Use AdvancedVideo** when: You need simple video playback with transformations
- ‚úÖ **Use Video Player** when: You need playlists, recommendations, ads, chapters, or other advanced features

## TypeScript Patterns

### Type Imports
- ‚úÖ Import types from `@cloudinary/url-gen`:
  ```tsx
  import type { CloudinaryImage } from '@cloudinary/url-gen';
  import type { CloudinaryVideo } from '@cloudinary/url-gen';
  ```
- ‚úÖ Type image instance: `const img: CloudinaryImage = cld.image('id')`
- ‚úÖ Type video instance: `const video: CloudinaryVideo = cld.video('id')`

### Upload Result Types
- ‚úÖ Define interface for upload results:
  ```tsx
  interface CloudinaryUploadResult {
    public_id: string;
    secure_url: string;
    url: string;
    width: number;
    height: number;
    format: string;
    resource_type: string;
    bytes: number;
    created_at: string;
    // Add other fields as needed
  }
  ```
- ‚úÖ Type upload callbacks:
  ```tsx
  onUploadSuccess?: (result: CloudinaryUploadResult) => void;
  ```
- ‚ùå **WRONG**: `onUploadSuccess?: (result: any) => void`
- ‚úÖ **CORRECT**: Use proper interface or type definition

### Environment Variable Typing
- ‚úÖ Create `vite-env.d.ts` for type safety:
  ```tsx
  /// <reference types="vite/client" />
  
  interface ImportMetaEnv {
    readonly VITE_CLOUDINARY_CLOUD_NAME: string;
    readonly VITE_CLOUDINARY_UPLOAD_PRESET?: string;
  }
  
  interface ImportMeta {
    readonly env: ImportMetaEnv;
  }
  ```
- ‚úÖ Access with type safety: `import.meta.env.VITE_CLOUDINARY_CLOUD_NAME`

### Type Guards and Safety
- ‚úÖ Type guard for window.cloudinary:
  ```tsx
  function isCloudinaryLoaded(): boolean {
    return typeof window !== 'undefined' && 
           typeof window.cloudinary !== 'undefined';
  }
  ```
- ‚úÖ Use type guards before accessing:
  ```tsx
  if (isCloudinaryLoaded()) {
    window.cloudinary.createUploadWidget(...);
  }
  ```

### Ref Typing Patterns
- ‚úÖ Type refs properly:
  ```tsx
  // Video element ref
  const videoRef = useRef<HTMLVideoElement>(null);
  
  // Button ref
  const buttonRef = useRef<HTMLButtonElement>(null);
  
  // Widget ref (use unknown if types not available)
  const widgetRef = useRef<unknown>(null);
  ```

### Type Narrowing
- ‚úÖ Handle optional values with type narrowing:
  ```tsx
  const preset = uploadPreset || undefined; // Type: string | undefined
  
  // Type narrowing in conditionals
  if (uploadPreset) {
    // TypeScript knows uploadPreset is string here
    console.log(preset.length);
  }
  ```

### Avoid `any` Type
- ‚ùå **WRONG**: `const result: any = ...`
- ‚úÖ **CORRECT**: Use proper interface or `unknown` with type guards
- ‚úÖ **CORRECT**: `const result: unknown = ...` then narrow with type guards
- ‚úÖ When types aren't available, use `unknown` and narrow:
  ```tsx
  function handleResult(result: unknown) {
    if (result && typeof result === 'object' && 'public_id' in result) {
      // TypeScript knows result has public_id
      const uploadResult = result as CloudinaryUploadResult;
    }
  }
  ```

## Best Practices
- ‚úÖ Always use `fill()` resize for responsive images
- ‚úÖ Always end transformations with `.delivery(format(auto())).delivery(quality(autoQuality()))`
- ‚úÖ Use `placeholder()` and `lazyload()` plugins together
- ‚úÖ Always add `width` and `height` attributes to `AdvancedImage`
- ‚úÖ Store `public_id` from upload success, not full URL
- ‚úÖ Always dispose video player in useEffect cleanup
- ‚úÖ Use TypeScript for better autocomplete and error catching
- ‚úÖ Prefer `unknown` over `any` when types aren't available
- ‚úÖ Use type guards for runtime type checking
- ‚úÖ Define interfaces for Cloudinary API responses
- ‚úÖ Create `vite-env.d.ts` for environment variable typing
- ‚úÖ Use proper HTML element types for refs

---

# ‚ö†Ô∏è COMMON ERRORS & SOLUTIONS

## Environment Variable Errors

### "Cloud name is required"
- ‚ùå Problem: `VITE_CLOUDINARY_CLOUD_NAME` not set or wrong prefix
- ‚úÖ Solution:
  1. Check `.env` file exists in project root
  2. Verify variable is `VITE_CLOUDINARY_CLOUD_NAME` (with `VITE_` prefix!)
  3. Restart dev server after adding .env variables

### "VITE_ prefix required" or env var is undefined
- ‚ùå Problem: Variable doesn't have `VITE_` prefix
- ‚úÖ Solution:
  1. Rename `CLOUDINARY_CLOUD_NAME` ‚Üí `VITE_CLOUDINARY_CLOUD_NAME`
  2. Restart dev server
  3. Use `import.meta.env.VITE_CLOUDINARY_CLOUD_NAME` (not `process.env`)

## Import Errors

### "Cannot find module" or wrong import
- ‚ùå Problem: Importing from wrong package
- ‚úÖ Solution:
  - Components: `@cloudinary/react` (not `@cloudinary/url-gen`)
  - Transformations: `@cloudinary/url-gen/actions/*` (not `@cloudinary/react`)
  - Cloudinary class: `@cloudinary/url-gen` (not `@cloudinary/react`)

## Transformation Errors

### "Transformation not working" or image looks wrong
- ‚ùå Problem: Incorrect transformation syntax
- ‚úÖ Solution:
  1. Check transformation is chained: `cld.image('id').resize(...).effect(...)`
  2. Verify actions are imported from correct modules
  3. Ensure image public_id is correct and accessible
  4. Check transformation syntax matches v2 (not v1)
  5. Format/quality must be separate: `.delivery(format(auto())).delivery(quality(autoQuality()))`

### Wrong transformation syntax
- ‚ùå WRONG: `<AdvancedImage src="image.jpg" width={800} />`
- ‚úÖ CORRECT: 
  ```tsx
  const img = cld.image('image.jpg').resize(fill().width(800));
  <AdvancedImage cldImg={img} />
  ```

## Plugin Errors

### "Responsive images not working" or "Placeholder issues"
- ‚ùå Problem: Plugins not configured correctly
- ‚úÖ Solution:
  1. Must use `responsive()` plugin with `fill()` resize
  2. Include both `placeholder()` and `lazyload()` plugins
  3. Check image is accessible and public_id is correct
  4. Verify plugins are in array: `plugins={[responsive(), placeholder(), lazyload()]}`
  5. Always add `width` and `height` attributes

### Plugins not working
- ‚ùå WRONG: `<AdvancedImage cldImg={img} lazyLoad placeholder />`
- ‚úÖ CORRECT: `<AdvancedImage cldImg={img} plugins={[lazyload(), placeholder()]} />`
- ‚úÖ Plugins must be imported from `@cloudinary/react`, not `@cloudinary/url-gen`

## Upload Widget Errors

### Upload fails (unsigned uploads) ‚Äî first check upload preset
- ‚ùå Problem: Upload fails when using unsigned upload
- ‚úÖ **Debug checklist** (in order):
  1. **Is the upload preset configured?** Check `.env` has `VITE_CLOUDINARY_UPLOAD_PRESET=your-preset-name` (exact name, no typos)
  2. **Does the preset exist?** Cloudinary dashboard ‚Üí Settings ‚Üí Upload ‚Üí Upload presets
  3. **Is it Unsigned?** Preset must be "Unsigned" for client-side uploads (no API key/secret in browser)
  4. **Env reloaded?** Restart the dev server after any `.env` change
- ‚úÖ If all above are correct, then check: script loaded in `index.html`, cloud name set, and network/console for the actual error message

### "Upload preset not found" or "Invalid upload preset"
- ‚ùå Problem: Preset doesn't exist or is signed
- ‚úÖ Solution:
  1. Create unsigned upload preset in Cloudinary dashboard
  2. Go to `settings/upload/presets` > Add upload preset
  3. Set to "Unsigned" mode
  4. Copy exact preset name to `.env` as `VITE_CLOUDINARY_UPLOAD_PRESET`
  5. Restart dev server

### "Cannot upload large images" or "Upload fails for large files"
- ‚ùå Problem: File too large or script not loaded
- ‚úÖ Solution:
  1. Use chunked uploads for files > 20MB
  2. Check upload preset has appropriate limits in dashboard
  3. Verify `window.cloudinary` script is loaded in `index.html`
  4. Consider using server-side upload for very large files

### Widget not opening
- ‚ùå Problem: Script not loaded or initialization issue
- ‚úÖ Solution:
  1. Ensure script is in `index.html`: `<script src="https://upload-widget.cloudinary.com/global/all.js" async></script>`
  2. Check widget initializes in `useEffect` after `window.cloudinary` is available
  3. Verify upload preset is set correctly

### User needs secure/signed uploads
- ‚ùå Problem: User asks for secure uploads; unsigned preset or client-side secret is not acceptable.
- ‚úÖ Use signed preset + server-side signature. Use **`uploadSignature` as a function** (not `signatureEndpoint`); fetch `api_key` from server first; include `uploadPreset` in widget config; server must include `upload_preset` in signed params. Use Cloudinary Node SDK **v2** on server. Never expose or commit the API secret.
- ‚úÖ See PATTERNS ‚Üí "Signed vs unsigned uploads" and "Secure (Signed) Uploads" ‚Üí "How the client gets credentials (working pattern)".

### "Where do I put my API key and secret?" / "Never commit API key or secret"
- ‚ùå Problem: User needs to store `CLOUDINARY_API_KEY` and `CLOUDINARY_API_SECRET` securely, or is told to "create a .env file" and worries it will overwrite the existing Vite `.env`.
- ‚úÖ Do not put them in root `.env`. Create `server/.env` with `CLOUDINARY_CLOUD_NAME`, `CLOUDINARY_API_KEY`, `CLOUDINARY_API_SECRET`; add `server/.env` to `.gitignore`; load only in the server. Never commit API key or secret.
- ‚úÖ See PATTERNS ‚Üí "Secure (Signed) Uploads" ‚Üí "Where to put API key and secret (server-only, never committed)".

### "Invalid Signature" or "Missing required parameter - api_key"
- ‚ùå Problem: Signed upload fails with "Invalid Signature" or "Missing required parameter - api_key".
- ‚úÖ **Use the working pattern:** (1) Use **`uploadSignature` as a function** (not `signatureEndpoint`). (2) **Fetch `api_key` from server** before creating the widget (API key is not secret). (3) **Include `uploadPreset` in widget config** so the widget includes it in `params_to_sign`. (4) **Server must include `upload_preset` in the signed params** (add it if the client did not send it). (5) Use **Cloudinary Node.js SDK v2** on the server (`import { v2 as cloudinary } from 'cloudinary'`), not v1 (e.g. 1.47.0).
- ‚úÖ **Common mistakes:** Using `signatureEndpoint` instead of `uploadSignature` function; omitting `uploadPreset` from widget config; server not adding `upload_preset` to signature params; using SDK v1 for signing; not fetching `api_key` from server before creating the widget. If using `ml_default`, ensure it still exists (user may have deleted it); otherwise create a signed preset in the dashboard.
- ‚úÖ See PATTERNS ‚Üí "Secure (Signed) Uploads" ‚Üí "How the client gets credentials (working pattern)".

## Video Errors

### "AdvancedVideo not working" or "Video not displaying"
- ‚ùå Problem: Wrong component or incorrect setup
- ‚úÖ Solution:
  1. Verify you're using `AdvancedVideo` from `@cloudinary/react` (not video player)
  2. Check video instance is created: `const video = cld.video(publicId)`
  3. **NO CSS IMPORT NEEDED** - AdvancedVideo doesn't require CSS import
  4. ‚ùå **WRONG**: `import '@cloudinary/react/dist/cld-video-player.css'` (this path doesn't exist)
  5. Verify public ID is correct and video exists in Cloudinary
  6. Check transformations are chained correctly (same as images)

### "Failed to resolve import @cloudinary/react/dist/cld-video-player.css"
- ‚ùå Problem: Trying to import CSS that doesn't exist in `@cloudinary/react`
- ‚úÖ Solution:
  1. **Remove the CSS import** - AdvancedVideo doesn't need it
  2. The `cld-video-player.css` file is only for `cloudinary-video-player` package
  3. AdvancedVideo uses native HTML5 video elements - no CSS required
  4. If you need styled video player, use `cloudinary-video-player` instead

### "Video player not working" or "Player not initializing"
- ‚ùå Problem: Configuration or initialization issue with standalone player
- ‚úÖ Solution:
  1. Check `cloud_name` is provided in player config
  2. Ensure CSS file is imported: `import 'cloudinary-video-player/dist/cld-video-player.css'`
  3. Verify player is initialized in `useEffect` with proper cleanup
  4. Check video element has required classes: `cld-video-player cld-fluid`
  5. Always call `player.dispose()` in useEffect cleanup function
  6. For advanced features, ensure required modules are imported

### Confusion between AdvancedVideo and Video Player
- ‚ùå WRONG: Using `cloudinary-video-player` when you just need transformations
- ‚úÖ CORRECT: Use `AdvancedVideo` from `@cloudinary/react` for simple video playback with transformations
- ‚ùå WRONG: Using `AdvancedVideo` when you need playlists/recommendations/ads
- ‚úÖ CORRECT: Use `cloudinary-video-player` for advanced features like playlists, recommendations, ads

### Memory leak from video player
- ‚ùå WRONG: Not disposing player in cleanup
- ‚úÖ CORRECT: Always dispose player:
  ```tsx
  useEffect(() => {
    const player = cloudinary.videoPlayer(ref.current, config);
    return () => player.dispose(); // Always cleanup!
  }, [dependencies]);
  ```

## TypeScript Errors

### "TypeScript errors on transformations"
- ‚ùå Problem: Missing types or wrong imports
- ‚úÖ Solution:
  1. Import types from `@cloudinary/url-gen`
  2. Use proper action imports: `import { fill } from '@cloudinary/url-gen/actions/resize'`
  3. Type the image instance if needed: `const img: CloudinaryImage = cld.image('id')`
  4. Ensure all imports are from correct modules

### "Type 'any' is not assignable" or "Parameter 'result' implicitly has 'any' type"
- ‚ùå Problem: Using `any` type or missing type definitions
- ‚úÖ Solution:
  1. Define interface for upload results: `interface CloudinaryUploadResult { ... }`
  2. Type callbacks: `onUploadSuccess?: (result: CloudinaryUploadResult) => void`
  3. Use `unknown` instead of `any` when types aren't available
  4. Add type guards to narrow `unknown` types

### "Property 'cloudinary' does not exist on type 'Window'"
- ‚ùå Problem: Missing type declaration for window.cloudinary
- ‚úÖ Solution:
  ```tsx
  declare global {
    interface Window {
      cloudinary?: {
        createUploadWidget: (config: any, callback: any) => any;
      };
    }
  }
  ```
- ‚úÖ Or use type guard: `if (typeof window.cloudinary !== 'undefined')`

### "Property 'VITE_CLOUDINARY_CLOUD_NAME' does not exist on type 'ImportMetaEnv'"
- ‚ùå Problem: Missing type definitions for Vite environment variables
- ‚úÖ Solution:
  1. Create `vite-env.d.ts` file
  2. Add interface: `interface ImportMetaEnv { readonly VITE_CLOUDINARY_CLOUD_NAME: string; }`
  3. Reference Vite types: `/// <reference types="vite/client" />`

### "Type 'null' is not assignable to type 'RefObject'"
- ‚ùå Problem: Incorrect ref typing
- ‚úÖ Solution:
  1. Use proper HTML element type: `useRef<HTMLVideoElement>(null)`
  2. Use `unknown` for widget refs if types aren't available: `useRef<unknown>(null)`
  3. Check for null before accessing: `if (ref.current) { ... }`

---

## Quick Reference Checklist

When something isn't working, check:
- [ ] Environment variables have `VITE_` prefix (client); **never** put API secret in `VITE_` vars
- [ ] Dev server was restarted after .env changes
- [ ] Imports are from correct packages
- [ ] Transformations are chained on image instance
- [ ] Format/quality use separate `.delivery()` calls
- [ ] Plugins are in array format
- [ ] Upload widget script is loaded in `index.html`
- [ ] **Upload fails (unsigned)?** ‚Üí Is `VITE_CLOUDINARY_UPLOAD_PRESET` set? Preset exists and is Unsigned in dashboard?
- [ ] **Secure uploads?** ‚Üí Use `uploadSignature` as function (not `signatureEndpoint`); fetch `api_key` from server first; include `uploadPreset` in widget config; server includes `upload_preset` in signed params; use Cloudinary Node SDK v2 on server; never expose or commit API secret
- [ ] **Where do API key/secret go?** ‚Üí **Do not** put in root `.env`. Use **`server/.env`**; add to `.gitignore`; load only in server. **Never commit** API key or secret
- [ ] Upload preset is unsigned (for simple client uploads)
- [ ] Video player is disposed in cleanup
- [ ] CSS files are imported for video player
- [ ] TypeScript types are properly imported
- [ ] Upload result types are defined (not using `any`)
- [ ] Environment variables are typed in `vite-env.d.ts`
- [ ] Refs are properly typed with HTML element types